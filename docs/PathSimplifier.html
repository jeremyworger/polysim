<!DOCTYPE html>

<html>
<head>
  <title>Path Simplifier</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
  <link rel="stylesheet" href="gh-fork-ribbon.css" />
</head>
<body>
  <div id="container">
    <div class="github-fork-ribbon-wrapper left-bottom">
        <div class="github-fork-ribbon">
            <a href="https://github.com/mkacz91/PolylineSimplification">Fork me on GitHub</a>
        </div>
    </div>
    <div id="background"></div>

      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page_wrapper">
            <div id="jump_page">


                <a class="source" href="GUI.html">
                  GUI.pde
                </a>


                <a class="source" href="Line.html">
                  Line.pde
                </a>


                <a class="source" href="LineFitter.html">
                  LineFitter.pde
                </a>


                <a class="source" href="Math.html">
                  Math.pde
                </a>


                <a class="source" href="Path.html">
                  Path.pde
                </a>


                <a class="source" href="PathSimplifier.html">
                  PathSimplifier.pde
                </a>


                <a class="source" href="../index.html">
                  PolylineSimplification.pde
                </a>


                <a class="source" href="SimplePathHull.html">
                  SimplePathHull.pde
                </a>

            </div>
          </div>
        </li>
      </ul>

    <ul class="sections">



        <li id="section-1">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1 id="path-simplifier">Path Simplifier</h1>

            </div>

        </li>


        <li id="section-2">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>The main idea of the simplification algorithm is to find the shortest route
(we use <em>route</em> instead of <em>path</em> to avoid ambiguity with the polyline) in
the (unweighted) <em>admissible segment graph</em>. The vertices of this graph are
the path points themselves. Two points, with indices <em>i</em> and <em>j</em>, <em>i</em> &lt; <em>j</em>,
are connected if they fulfill the following conditions:</p>
<ol>
<li><p>The subpath <em>S</em> spanning between <em>i</em> and <em>j</em>, inclusive, is <em>simple</em>,
i.e., has no self intersections.</p>
</li>
<li><p>The maximal distance between any point of the subpath <em>S</em>, and the
optimal linear approximation <em>L</em> of path <em>S</em>, does not exceed the
threshold.</p>
</li>
<li><p>Point <em>i</em> is a pioneer with respect to line <em>L</em> among <em>S</em>.</p>
</li>
<li><p>Point <em>j</em> is a pioneer with respect to line <em>L</em> among <em>S</em>.</p>
</li>
</ol>
<p>After the shortest route is found, the simplified path is made up of the
linear approximations of subpaths that correspond to the route’s edges.
For details, see: <code>PathSimplifier.getSimplified()</code>.</p>
<p>But still some definitions remain unclear. By <em>optimal linear approximation</em>
of a point set we would normally understand a line which has the smallest
maximal distance to the points. But since finding such line is
computationally hard, we use a line that is optimal in the <em>least squares</em>
sense as a fair approximation. After linear preprocessing of a point
sequence, such lines can be found in constant time for any subsequence. This
is implemented by <a href="LineFitter.html"><code>LineFitter</code></a>.</p>
<p>For a set of points <em>S</em>, and a line <em>L</em>, point <em>p</em> is a <em>pioneer</em>, if it
belongs to <em>S</em> and it’s projection on <em>L</em> is the most external among
projection of all other points. In other words, the projections of other
elements of <em>S</em> reside on one side of the <em>p</em>‘s projection. Typically, there
are two pioneers for given <em>S</em> and <em>L</em>.</p>
<p>A pioneer always belongs to the <em>convex hull</em> of it’s set. Moreover, if
we have such hull for our disposition, we can verify in constant time whether
a given point belonging to that hull is a pioneer. For details, refer to
<code>PathSimplifier.isPioneer()</code>. Moreover, convex hull for simple polygonal
lines can be computed online in linear time, as is done by
<a href="SimplePathHull.html"><code>SimplePathHull</code></a>.</p>
<p>To maintain a simplified path online, as the points arrive, the strategy is
to take the newest point, say <em>j</em>, and for, <em>i</em> = <em>j</em> - 1, <em>j</em> - 2, …,
0, check if <em>i</em> and <em>j</em> can be connected. Along the way, seek the shothest
route using a dynamic programming approach.</p>
<p>From what was already said, it follows that conditions 1, 3, and 4, can be
resolved in constant time for each <em>i</em>. The only problem remains for the
2nd condition. But the approximation of the maximal distance can still be
effectively computed, using the fact, that all points lie in small radius
from the last optimal line. This task is handled by <code>ErrorBox</code>, later in this
file.</p>
<p>Also note, that if any of the conditions: 1, 2, 4, fails, no further iteration
is necessary, because we will never recover. That said, the resulting online
step is pessimistically linear in time, but the practical complexity is much
better.</p>

            </div>

        </li>


        <li id="section-3">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h2 id="pathsimplifier-class">PathSimplifier Class</h2>

            </div>

        </li>


        <li id="section-4">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Maintains a simplified version of path. Can be attached to a <code>Path</code> object
as a listener and then adjusts the simplified path online on any
modification.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PathSimplifier</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IPathListener</span>
</span>{</pre></div></div>

        </li>


        <li id="section-5">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Additional information stored for each point of the original path</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PointTag</span>
  </span>{</pre></div></div>

        </li>


        <li id="section-6">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Distance to the starting point in the admissible segment graph</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> dist;</pre></div></div>

        </li>


        <li id="section-7">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Index of the next vertex along the shortest path in the admissible
segment graph</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> next;</pre></div></div>

        </li>


        <li id="section-8">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Determines whether the segment starting in this point takes part in an
intersection with another non-adjecent segment later in the path.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> cut;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PointTag</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dist, <span class="hljs-keyword">int</span> next)</span> </span>{
      <span class="hljs-keyword">this</span>.dist = dist;
      <span class="hljs-keyword">this</span>.next = next;
      <span class="hljs-keyword">this</span>.cut = <span class="hljs-keyword">false</span>;
    }
  }</pre></div></div>

        </li>


        <li id="section-9">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>The original path</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Path path;</pre></div></div>

        </li>


        <li id="section-10">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Length of the path being simplified. Normally this should be equivalent to
<code>path.length()</code> but in the initial steps, when starting with a non empty
path, it may be smaller, in order to artificially simulate the construction
process.</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> pathLength;</pre></div></div>

        </li>


        <li id="section-11">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p><code>LineFitter</code> to retrieve information about optimal linear approximation of
selected path segments. It is registered as listener to <code>path</code> before this
<code>PathSimplifier</code>, so when we receive a path change callback, the fitter can
be assumed to already be in the newest state.</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> LineFitter fitter;</pre></div></div>

        </li>


        <li id="section-12">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Additional information stored for the points of simplified path. The
indexing of <code>tags</code> is identical to that of <code>path</code>‘s.</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;PointTag&gt; tags = <span class="hljs-keyword">new</span> ArrayList&lt;PointTag&gt;();</pre></div></div>

        </li>


        <li id="section-13">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>The maximal allowed squared distance between original path points and the
simplified path.</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> thresholdSq;</pre></div></div>

        </li>


        <li id="section-14">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Possible events that may occur during addmisibility checking of segment
<code>ij</code> during <code>onAddPoint()</code>. Used for visualization purposes and
debugging.</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Event
  {</pre></div></div>

        </li>


        <li id="section-15">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>The segment obeys all rules from 1 to 4</p>

            </div>

            <div class="content"><div class='highlight'><pre>    ACCEPT,</pre></div></div>

        </li>


        <li id="section-16">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Point <code>i</code> takes part in an intesection (rule 1 violated)</p>

            </div>

            <div class="content"><div class='highlight'><pre>    CUT,</pre></div></div>

        </li>


        <li id="section-17">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>The distance to optimal line exceeds threshold (rule 2 violated)</p>

            </div>

            <div class="content"><div class='highlight'><pre>    THRESHOLD,</pre></div></div>

        </li>


        <li id="section-18">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Point <code>i</code> is not a pioneer (rule 3 violated)</p>

            </div>

            <div class="content"><div class='highlight'><pre>    PIONEER_WEAK,</pre></div></div>

        </li>


        <li id="section-19">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Point <code>j</code> is not a pioneer (rule 4 violated)</p>

            </div>

            <div class="content"><div class='highlight'><pre>    PIONEER_STRONG
  }</pre></div></div>

        </li>


        <li id="section-20">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>List of events that occured for each considered <code>i</code> during last
<code>onAddPoint()</code>. Used for visualization purposes and debugging.</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> List&lt;Event&gt; trace = <span class="hljs-keyword">new</span> ArrayList&lt;Event&gt;();</pre></div></div>

        </li>


        <li id="section-21">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Creates a simplifier attached to given path and using given threshold as
the maximal distance between the path points and the simplified path.</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PathSimplifier</span><span class="hljs-params">(Path path, <span class="hljs-keyword">float</span> threshold)</span> </span>{
    <span class="hljs-keyword">this</span>.path = path;
    <span class="hljs-keyword">this</span>.fitter = <span class="hljs-keyword">new</span> LineFitter(path);
    <span class="hljs-keyword">this</span>.thresholdSq = threshold * threshold;
    path.addListener(<span class="hljs-keyword">this</span>);</pre></div></div>

        </li>


        <li id="section-22">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>We artificially invoke the modification callbacks to simulate the
construction steps that have taken place before this simplifier was
created</p>

            </div>

            <div class="content"><div class='highlight'><pre>    onClear(path);
    <span class="hljs-keyword">for</span> (PVector p : path)
      onAddPoint(path, p);
  }

  <span class="hljs-annotation">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClear</span><span class="hljs-params">(Path sender)</span> </span>{
    pathLength = <span class="hljs-number">0</span>;
    tags.clear();
  }

  <span class="hljs-annotation">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAddPoint</span><span class="hljs-params">(Path sender, PVector p)</span> </span>{
    trace.clear();
    trace.add(Event.ACCEPT);
    <span class="hljs-keyword">int</span> j = pathLength++;
    PVector pj = p; <span class="hljs-comment">// equivalent to path.point(j)</span>
    ErrorBox errorBox = <span class="hljs-keyword">new</span> ErrorBox(fitter.fitLine(j, j), pj);
    SimplePathHull hull = <span class="hljs-keyword">new</span> SimplePathHull();
    SimplePathHull.Node nj = hull.offer(pj);

    <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) {
      tags.add(<span class="hljs-keyword">new</span> PointTag(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>));
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">int</span> next = j - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> dist = tags.get(next).dist;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = j - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) {
      PVector pi = path.point(i);
      PointTag ti = tags.get(i);</pre></div></div>

        </li>


        <li id="section-23">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Stop if the segment starting at <code>i</code> intersects with any other segment along
the path to <code>j</code>, because <code>hull</code> only handles simple polylines.</p>

            </div>

            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (
        ti.cut ||
        i &lt; j - <span class="hljs-number">2</span> &amp;&amp;
        Geometry.intersect(pi, path.point(i + <span class="hljs-number">1</span>), path.point(j - <span class="hljs-number">1</span>), pj)
      ) {
        ti.cut = <span class="hljs-keyword">true</span>;
        trace.add(Event.CUT);
        <span class="hljs-keyword">break</span>;
      }</pre></div></div>

        </li>


        <li id="section-24">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Compute the optimal line approximation along with the maximal error
approximation and stop if the threshold is violated</p>

            </div>

            <div class="content"><div class='highlight'><pre>      Line line = fitter.fitLine(i, j);
      errorBox.extend(line, pi);
      <span class="hljs-keyword">if</span> (errorBox.error() &gt; thresholdSq) {
        trace.add(Event.THRESHOLD);
        <span class="hljs-keyword">break</span>;
      }</pre></div></div>

        </li>


        <li id="section-25">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Consider the edge between <code>i</code> and <code>j</code> as admissible, if both points are
pioneers with respect to the optimal line. If the <code>j</code>th point is not
a pioneer, then it will never get back to being one, so we can break
right here.</p>

            </div>

            <div class="content"><div class='highlight'><pre>      SimplePathHull.Node ni = hull.offer(pi);
      <span class="hljs-keyword">if</span> (ni == <span class="hljs-keyword">null</span> || !isPioneer(line, ni)) {
        trace.add(Event.PIONEER_WEAK);
        <span class="hljs-keyword">continue</span>;
      }
      <span class="hljs-keyword">if</span> (!isPioneer(line, nj)) {
        trace.add(Event.PIONEER_STRONG);
        <span class="hljs-keyword">break</span>;
      }

      trace.add(Event.ACCEPT);
      <span class="hljs-keyword">if</span> (ti.dist &lt; dist) {
        next = i;
        dist = ti.dist;
      }
    }

    tags.add(<span class="hljs-keyword">new</span> PointTag(dist + <span class="hljs-number">1</span>, next));
  }</pre></div></div>

        </li>


        <li id="section-26">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>For a given line an a convex hull point, determines whether that point is
a pioneer with respect to that line</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPioneer</span><span class="hljs-params">(Line line, SimplePathHull.Node n)</span> </span>{
    <span class="hljs-keyword">if</span> (!n.isValid())
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</pre></div></div>

        </li>


        <li id="section-27">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>For a hull point, it suffices to check whether the projections of its
adjecent hull points lie on the same side of its projection</p>

            </div>

            <div class="content"><div class='highlight'><pre>    PVector t = line.tangent();
    <span class="hljs-keyword">float</span> dp = PVector.dot(t, Geometry.span(n.pos(), n.prev().pos()));
    <span class="hljs-keyword">float</span> dn = PVector.dot(t, Geometry.span(n.pos(), n.next().pos()));
    <span class="hljs-keyword">return</span> dp * dn &gt;= <span class="hljs-number">0</span>;
  }</pre></div></div>

        </li>


        <li id="section-28">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Retrieves the simplified path</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">public</span> Path <span class="hljs-title">getSimplified</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (pathLength &lt;= <span class="hljs-number">1</span>)
      <span class="hljs-keyword">return</span> path;

    Path result = <span class="hljs-keyword">new</span> Path();</pre></div></div>

        </li>


        <li id="section-29">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>We go along the shortest route and take the line approximations of the
subpaths corresponding to passed edges. We add intersectionf of
subsequent lines as points of the simplified path. The first and the last
point are projections of the first and last point of the original path
onto the corresponding lines.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">int</span> j = pathLength - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> i = tags.get(j).next;
    Line line = fitter.fitLine(i, j);
    result.addPoint(Geometry.project(path.point(j), line));
    <span class="hljs-keyword">while</span> (i != <span class="hljs-number">0</span>) {
      j = i;
      i = tags.get(j).next;
      PVector pj = path.point(j);
      Line prevLine = line;
      line = fitter.fitLine(i, j);
      PVector p = Geometry.intersection(line, prevLine);</pre></div></div>

        </li>


        <li id="section-30">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p><strong>TODO:</strong> If the lines are parallel or some other crazy stuff, I can’t
seem to find any good solution without violating the threshold
condition. Honestly, just adding <code>p</code>, only guarantees that we are within two
threshold of the original path.</p>

            </div>

            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (isSingular(p) || Geometry.distSq(p, pj) &gt; <span class="hljs-number">4</span> * thresholdSq)
        result.addPoint(pj);
      <span class="hljs-keyword">else</span>
        result.addPoint(p);
    }

    result.addPoint(Geometry.project(path.point(<span class="hljs-number">0</span>), line));
    <span class="hljs-keyword">return</span> result;
  }
}</pre></div></div>

        </li>


        <li id="section-31">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <h2 id="errorbox-class">ErrorBox Class</h2>

            </div>

        </li>


        <li id="section-32">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Manages a rectangle defined in line coordinates. It is used as a bound for
positions of points of a given set. For detailed explanation of line
coordinates, see: <a href="Line.html"><code>Line</code></a>.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrorBox</span>
</span>{</pre></div></div>

        </li>


        <li id="section-33">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Line in which cooordinate system this rectangle is defined</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">private</span> Line line;</pre></div></div>

        </li>


        <li id="section-34">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Minimum and maximum <em>s</em> coordinate</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> s0, s1;</pre></div></div>

        </li>


        <li id="section-35">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Minimum and maximum <em>t</em> coordinate</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> t0, t1;</pre></div></div>

        </li>


        <li id="section-36">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>Creates a new error box in given line coordinate system, containing
a single point</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ErrorBox</span><span class="hljs-params">(Line line, PVector p)</span> </span>{
    <span class="hljs-keyword">this</span>.line = line;
    LVector l = line.map(p);
    <span class="hljs-keyword">this</span>.s0 = <span class="hljs-keyword">this</span>.s1 = l.s;
    <span class="hljs-keyword">this</span>.t0 = <span class="hljs-keyword">this</span>.t1 = l.t;
  }</pre></div></div>

        </li>


        <li id="section-37">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>Adds new point to the bounded set, possibly enlarging the box, and
converts the representation to coordinate system of a new line.</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">extend</span><span class="hljs-params">(Line line, PVector p)</span> </span>{
    LVector l = line.map(p);
    LVector l00 = line.remap(<span class="hljs-keyword">this</span>.line, s0, t0);
    LVector l01 = line.remap(<span class="hljs-keyword">this</span>.line, s0, t1);
    LVector l10 = line.remap(<span class="hljs-keyword">this</span>.line, s1, t0);
    LVector l11 = line.remap(<span class="hljs-keyword">this</span>.line, s1, t1);

    <span class="hljs-keyword">this</span>.line = line;
    s0 = min(l.s, l00.s, l01.s, l10.s, l11.s);
    s1 = max(l.s, l00.s, l01.s, l10.s, l11.s);
    t0 = min(l.t, l00.t, l01.t, l10.t, l11.t);
    t1 = max(l.t, l00.t, l01.t, l10.t, l11.t);
  }</pre></div></div>

        </li>


        <li id="section-38">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>Computes the largest possible value of the squared distance between a point
inside the rectangle, and the line defining its coordinate system</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">error</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> max(t0 * t0, t1 * t1) * (line.a * line.a + line.b * line.b);
  }</pre></div></div>

        </li>


        <li id="section-39">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>Gets the four rectangle vertices in cartesian coordinate system</p>

            </div>

            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">public</span> PVector[] getCartesianCorners() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PVector[] {
      line.unmap(s0, t0),
      line.unmap(s0, t1),
      line.unmap(s1, t1),
      line.unmap(s1, t0)
    };
  }
}</pre></div></div>

        </li>

    </ul>
  </div>
</body>
</html>
